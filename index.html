<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>My first three.js app</title>
	<script src="js/three.js"></script>
	<link rel="stylesheet" href="styles.css">
	<style>
		body {
			margin: 0;
		}
	</style>
</head>

<body>

	<!-- <div id='stars'></div>
	<div id='stars2'></div>
	<div id='stars3'></div> -->
	<!-- <div id='title'> -->
	<script>

		const scene = new THREE.Scene();
		const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);

		const renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		var geometry = new THREE.SphereGeometry(0.5, 128, 128)
		// const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
		const displacementMap = new THREE.TextureLoader().load(
			'assets/textures/moon_dis.jpg'
		)

		const texture = new THREE.TextureLoader().load('assets/textures/moon3.jpg');
		// const texture = new THREE.TextureLoader().load('assets/textures/earth.jpg');

		// immediately use the texture for material creation
		const material = new THREE.MeshStandardMaterial({ map: texture, displacementMap: displacementMap, displacementScale: 0.1, roughness: 50.0 });
		const cube = new THREE.Mesh(geometry, material);
		scene.add(cube);

		camera.position.z = 4;
		var light = new THREE.DirectionalLight(0xcccccc, 1.3)
		light.position.set(-10, 10, 60)
		scene.add(light)

		//Pos from latlon
		function calcPosFromLatLonRad(lat, lon, radius) {

			var phi = (90 - lat) * (Math.PI / 180);
			var theta = (lon + 180) * (Math.PI / 180);

			x = -((radius + 0.06) * Math.sin(phi) * Math.cos(theta));
			z = ((radius + 0.06) * Math.sin(phi) * Math.sin(theta));
			y = ((radius + 0.06) * Math.cos(phi));


			console.log([x, y, z]);
			return [x, y, z];
		}

		//Dots
		latlon = [-3.91, 21.3];
		var geometryDot = new THREE.SphereGeometry(0.025, 20, 20)
		var materialDot = new THREE.MeshBasicMaterial({
			color: new THREE.Color('red')
		})
		var point = new THREE.Mesh(geometryDot, materialDot);
		var latlonpoint = calcPosFromLatLonRad(latlon[0], latlon[1], 0.5);
		point.position.set(latlonpoint[0], latlonpoint[1], latlonpoint[2]);
		cube.add(point)

		//Rotate

		var targetRotationX = 0.5;
		var targetRotationOnMouseDownX = 0;

		var targetRotationY = 0.2;
		var targetRotationOnMouseDownY = 0;

		var mouseX = 0;
		var mouseXOnMouseDown = 0;

		var mouseY = 0;
		var mouseYOnMouseDown = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		var slowingFactor = 0.25;


		document.addEventListener('mousedown', onDocumentMouseDown, false);


		function onDocumentMouseDown(event) {

			event.preventDefault();

			document.addEventListener('mousemove', onDocumentMouseMove, false);
			document.addEventListener('mouseup', onDocumentMouseUp, false);
			document.addEventListener('mouseout', onDocumentMouseOut, false);

			mouseXOnMouseDown = event.clientX - windowHalfX;
			targetRotationOnMouseDownX = targetRotationX;

			mouseYOnMouseDown = event.clientY - windowHalfY;
			targetRotationOnMouseDownY = targetRotationY;
		}


		function onDocumentMouseMove(event) {

			mouseX = event.clientX - windowHalfX;

			targetRotationX = (mouseX - mouseXOnMouseDown) * 0.00025;

			mouseY = event.clientY - windowHalfY;

			targetRotationY = (mouseY - mouseYOnMouseDown) * 0.00025;
		}
		function onDocumentMouseUp(event) {

			document.removeEventListener('mousemove', onDocumentMouseMove, false);
			document.removeEventListener('mouseup', onDocumentMouseUp, false);
			document.removeEventListener('mouseout', onDocumentMouseOut, false);
		}

		function onDocumentMouseOut(event) {

			document.removeEventListener('mousemove', onDocumentMouseMove, false);
			document.removeEventListener('mouseup', onDocumentMouseUp, false);
			document.removeEventListener('mouseout', onDocumentMouseOut, false);
		}

		///hover

		document.addEventListener('mousemove', onMouseMove, false);
		// var mouse = {
		// 	x: 0, y: 0
		// }
		// var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
		// var ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

		function onMouseMove(event) {
			// // var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
			// // var ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
			var mouse = new THREE.Vector2();
    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			var raycaster = new THREE.Raycaster();
			raycaster.setFromCamera(mouse, camera);
			var intersects = raycaster.intersectObjects([point]);
			console.log('tems')
			// var tempTest = new THREE.MeshBasicMaterial({
			// 	color: new THREE.Color('white')
			// })
			intersects[0].object.material.color = new THREE.Color('white')
			console.log(intersects[0])
		}


		function animate() {
			requestAnimationFrame(animate);

			// cube.rotation.x += 0.01;
			// cube.rotation.y += 0.01;

			rotateAroundWorldAxis(cube, new THREE.Vector3(0, 1, 0), targetRotationX);
			rotateAroundWorldAxis(cube, new THREE.Vector3(1, 0, 0), targetRotationY);

			targetRotationY = targetRotationY * (1 - slowingFactor);
			targetRotationX = targetRotationX * (1 - slowingFactor);

			renderer.render(scene, camera);
		};

		function rotateAroundObjectAxis(object, axis, radians) {
			var rotationMatrix = new THREE.Matrix4();

			rotationMatrix.makeRotationAxis(axis.normalize(), radians);
			object.matrix.multiply(rotationMatrix);
			object.rotation.setFromRotationMatrix(object.matrix);

		}

		function rotateAroundWorldAxis(object, axis, radians) {

			var rotationMatrix = new THREE.Matrix4();

			rotationMatrix.makeRotationAxis(axis.normalize(), radians);
			rotationMatrix.multiply(object.matrix);                       // pre-multiply
			object.matrix = rotationMatrix;
			object.rotation.setFromRotationMatrix(object.matrix);
		}
		animate();
	</script>
</body>

</html>